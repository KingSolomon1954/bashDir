#################################################################
#
#         .bashrc file
#         gets sourced from ~/.bash_login for login shells.
#         gets sourced by bash itself for interactive shells.
#
#################################################################

#echo "bash $BASH_VERSION"

# If modules is configured on this work station
if [ -f /pkg/.init/bash -a -f /etc/modulefiles/osver \
    -a -f /bin/modulecmd ]; then

    . /pkg/.init/bash

    # Order gets stacked, so put most significant stuff last
    #
    module load base local xv tar top rlterm pine jdk rcs gzip \
        groff gdb gcc less X11 cde sys

    # source /pkg/.init/bash
    # module load base sys X11 ucb dot
    # setenv MODULEPATH ~/.modules:${MODULEPATH}

else

    platform=$(uname)
    # echo "Modules not setup on this workstation."
    
    if [ "${platform}" = "CYGWIN_NT-5.0" ]; then
        PATH=.:${PATH}
        PATH=${PATH}://c/Program\ Files/Jbuilder/jdk1.3/bin
        PATH=${PATH}://c/Program\ Files/doxygen/doxygen-1.2.10/bin
    else
        PATH=.:/usr/sbin:/usr/ucb:/sbin:/usr/bin:/bin
        PATH=${PATH}:/usr/bin/X11:/usr/local/bin/X11
        PATH=${PATH}:~/bin:/usr/local/bin:/usr/etc
    fi
fi

# Determine machine architecture in order to define
# platform specific setup; like the proper version of
# microemacs and paths.  SUN uses the "arch" command
# while DEC uses the "machine" command to return
# architecture. Could use "uname" here. Bash's $HOSTTYPE
# does not distinguish between Solaris & SunOS.

platform=$(uname)

if [ "${platform}" = "AIX" ]; then
    alias em=${HOME}/bin/microemacs.aix
    typeset -x VISUAL=${HOME}/bin/microemacs.aix
    # alias em="emacs -nw "
    # typeset -x VISUAL="emacs -nw" 
elif [ "${platform}" = "ULTRIX" ]; then
    alias em=${HOME}/bin/microemacs.ultrix
    typeset -x VISUAL=${HOME}/bin/microemacs.ultrix
    # alias mwm=/usr/lib/DXM/clients/mwm/mwm
elif [ "${platform}" = "SunOS" ]; then
    alias em=${HOME}/bin/microemacs.sun4
    typeset -x VISUAL=${HOME}/bin/microemacs.sun4
    # typeset -x MANPATH=/usr/man:/vol/gnu/man:/usr/local/man
    # MANPATH=${MANPATH}:/vol/X11/man:/usr/openwin/man
    # typeset -x OPENWINHOME=/usr/openwin
    # PATH=${PATH}:${OPENWINHOME}/bin

    typeset -x LD_LIBRARY_PATH=/usr/lib:/usr/openwin/lib:/usr/ucblib

    # Check for Solaris 
    osmajorrev=$(uname -r | cut -c1)
    if [ ${osmajorrev} -ge 5 ]; then
        # ?? PATH=${PATH}:/usr/ccs/bin:/usr/ccs/lib:/opt/SUNWmfwm/bin
        # PATH=${PATH}:/pkg/jdk/1.2.b3/sparc-sun-solaris2.6/bin
        # ?? PATH=${PATH}:/pkg/jdk/1.1.6/sparc-sun-solaris2.6/bin
        # ?? MANPATH=${MANPATH}:/opt/SUNWmfwm/man:/opt/SUNWspro/man
        # ?? MANPATH=${MANPATH}:/usr/dt/man
	alias me_exec=${HOME}/programs/microemacs_jasspa/mesunos55_99
	alias df="df -k"
	alias man="man -aF"
        alias who="who -T -H | sort"
        alias nstat="netstat -i 5"
        # typeset -x CLASSPATH=.:/pkg/jacl/1.0a1/sparc-sun-solaris2.5/jacl
        # ?? typeset -x CLASSPATH=.:/pkg/jpython/1.0.2/common-sun-java1.1.5/jpython.jar
        CLASSPATH=${CLASSPATH}:${HOME}/programs/jpython/lib
    fi
elif [ "${platform}" = "IRIX" -o "${platform}" = "IRIX64" ]; then
    # ?? PATH=${PATH}:/usr/bsd
    # IRIX returns OS revision as "m.n" string
    osminorrev=$(uname -r | cut -c3)
    if [ ${osminorrev} -ge 4 ]; then
        alias em=${HOME}/bin/microemacs.irix
        typeset -x VISUAL="${HOME}/bin/microemacs.irix"
    elif [ ${osminorrev} -ge 2 ]; then
        alias em=${HOME}/bin/microemacs.irix6.2
        typeset -x VISUAL="${HOME}/bin/microemacs.irix6.2"
    else
        alias em="emacs -nw "
        typeset -x VISUAL="emacs -nw "
    fi
    alias nstat="netstat -C 5"
    alias me_exec=${HOME}/programs/microemacs_jasspa/meirix6_99
    # ?? typeset -x MANPATH=/usr/share/catman:/usr/share/man:/usr/catman:/vol/gnu/man:/usr/local/man
    # Enable emacs line editing in dbx
    typeset -x LINEEDIT=""
    # dbx looks for EDITOR, not VISUAL
    typeset -x EDITOR=$VISUAL
    # Get Java stuff in the path
    # ?? PATH=${PATH}:/pkg/jdk/1.1.6/mips-sgi-irix6.5/bin
    # ?? typeset -x CLASSPATH=.:/pkg/jpython/1.0.2/common-sun-java1.1.5/jpython.jar
    CLASSPATH=${CLASSPATH}:${HOME}/programs/jpython/lib
    # typeset -x CLASSPATH=.:${DEV_WORK_TREE}/usrenv/gui/impact.zip
    # CLASSPATH=${CLASSPATH}:/pkg/bwt/2.0.5/common/jclass/bwt/lib/jcbwt205-classes.zip
    # CLASSPATH=${CLASSPATH}:${DEV_WORK_TREE}/usrenv/gui/symantec/symclass.zip
    # CLASSPATH=${CLASSPATH}:${DEV_WORK_TREE}/usrenv/gui/symantec/vecclass.zip

elif [ "${platform}" = "OSF1" ]; then
    alias em=${HOME}/bin/microemacs.osf1
    typeset -x VISUAL="${HOME}/bin/microemacs.osf1"
    # ?? typeset -x MANPATH=/usr/share/catman:/usr/share/man:/usr/catman:/vol/gnu/man:/usr/local/man
elif [ "${platform}" = "CYGWIN_NT-4.0" -o "${platform}" = "CYGWIN_NT-5.0" ]; then
    alias me_exec=c:/"Program\ Files"/Jasspa/MicroEmacs/me32.exe

    # Ignore case while completing
    set completion-ignore-case on

    unset MAILCHECK

    # On the PC, we'll use colors for ls and the like.
    declare COLOR_ARGS="--color=tty"

    # For the PC, show directories in color
    declare -x LS_COLORS="di=36:ex=33"

    # Turn on the use of NT extended attributes for storing file
    # permissions. Don't use this on a FAT partition.
    # declare -x CYGWIN=ntea

    alias rxvt='rxvt -bg black -fg "springgreen3" -fn "Andale Mono-14" -sl 1000 -e bash --login'
    declare -x TERM=cygwin
    declare -x MAKE_MODE=unix

    declare -x SHADE=$(echo ${HOME}/proj/shade | sed -e 's/\ /\\\ /g')

    # Key bindings here cause cygwin's .inputrc is busted.
    bind '"\C-l": kill-word'
    bind '"\C-j": backward-char'
    bind '"\C-g": forward-word'
    bind '"\C-b": backward-word'
    bind '"\C-i": complete'
fi

# --------------------------------------------------

# Shows symlinks in prompt instead of absolute path
set nolinks

# Set Prompt, user@hostname:current directory
if [ "${COLOR_ARGS}" = "" ]; then
    PS1="\u@\h:\w>\n"
else
    # Sets prompt background to be purple (45)
    # PS1="\e[0m\e[45m\u@\h:\w>\e[0m\n"
    PS1="\e[0m\e[44m\u@\h:\w>\e[0m\n"
fi

# --------------------------------------------------

alias m='make --no-print-directory'
alias mc='make --no-print-directory clean'
alias mm='make Makefile'
alias mms='make Makefiles'
alias md='make --no-print-directory JDEBUGFLAGS=-g "CDEBUGFLAGS=-g -DDEBUG"'
alias mt='make --no-print-directory "CDEBUGFLAGS=-DTRACE"'
alias mdt='make --no-print-directory "CDEBUGFLAGS=-g -DDEBUG -DTRACE"'
alias mtd='make --no-print-directory "CDEBUGFLAGS=-g -DDEBUG -DTRACE"'
alias mi='make --no-print-directory install'
alias mp='make --no-print-directory "CDEBUGFLAGS=-O3 -DNDEBUG"'

alias phone='me ~/admin/phone.txt'
alias type='type -p'

# --------------------------------------------------

set -o notify
#	If set, bash reports terminated background jobs immedi-
#	ately,  rather  than  waiting until before printing the
#	next primary prompt.

typeset -x FIGNORE=.o:.class
#	A colon-separated list of suffixes to ignore when  per-
#	forming filename completion. A filename whose suffix
#	matches one of the entries in FIGNORE is excluded from
#	the list of matched filenames.
#	A sample value is ``.o:~''.

# Using pine now, MBOX was used by elm.
# typeset -x MBOX=~/admin/mail/mbox

typeset history_control=ignoredups
#	If set to a value of ignoredups, lines matching the
#	last history line are not entered into history. If
#	set to a value of ignorespace, lines which begin
#	witha <space> are not entered on the history list. If
#	unset, or if set to any other value, all lines read
#	by the parser are saved on  the history list.

typeset command_oriented_history
#	If set, bash attempts to save all lines of a
#	multiple-line command in the same history entry. This
#	allows easy re-diting of mulit-line commands


# Our Timezone
typeset -x TZ=PST8PDT

# typeset -x WWW_HOME=http://www.ti.lmco.com
#	Set the Mosaic/WWW Home page; so Mosaic won't take so
#	long to open.

# --------------------------------------------------

# Determine a pager to use
PAGER="more -e"
if type less > /dev/null 2>&1; then
    PAGER="less -E"
fi
export PAGER

function l       () { ls -CF ${COLOR_ARGS} "$@"; }
function lsd     () { ls -1LF ${COLOR_ARGS} "$@" | grep /; }
function g       () { grep "$@" * | ${PAGER}; }
function ga      () { grep "$@" *.[c,C,h,H,s] *.cpp *.CPP 2> /dev/null | ${PAGER}; }
function gc      () { grep "$@" *.cpp *.CPP *.[cC] 2> /dev/null | ${PAGER}; }
function gh      () { grep "$@" *.[hH] 2> /dev/null | ${PAGER}; }
function gs      () { grep "$@" *.s *.S 2> /dev/null | ${PAGER}; }
function gj      () { grep "$@" *.java 2> /dev/null | ${PAGER}; }
function ghtm    () { grep "$@" *.htm *.html *.js 2> /dev/null | ${PAGER}; }
function gall    () { grep "$@" *.[c,C,h,H,s] *.cpp *.CPP 2> /dev/null | ${PAGER}; }
function f       () { find . -name "$*" -print; }
function ffgrep  () { find . -name \*.[ch] -print | xargs grep "$@"; }
function fdelete () { find . -name $1 -print -exec rm {} \; ; }
function psu     () { ps -fu ${1-${LOGNAME}} | grep -v grep; }

if [ "${platform}" = "AIX" ]; then
	function psa    () { ps aux $* | ${PAGER}; }
	function L      () { ls -la $* | ${PAGER} ; }
	function LL     () { ls -lisa $* | ${PAGER} ; }
elif [ "${platform}" = "IRIX" -o "${platform}" = "IRIX64" ]; then
	function psa    () { ps -fe $* | ${PAGER}; }
	function L      () { ls -la $* | ${PAGER} ; }
	function LL     () { ls -lisa $* | ${PAGER} ; }
	function l      () { ls -CFH $*; }
	function dbxhelp () { set - x; em /usr/lib/dbx.help; set +x; }
else
	function psa    () { ps auxw $* | ${PAGER}; }
	function L      () { ls -la ${COLOR_ARGS} $* ; }
	function LL     () { ls -lisag ${COLOR_ARGS} $* ; }
fi

unset platform
unset osmajorrev
unset osminorrev

# --------------------------------------------------
# JASSPA MicroEmacs
#
# This function automatically backgrounds microemacs 
# but not when the -n option is given.

if [ "${MEPATH}" = "" ]; then
    declare -x MEPATH=${HOME}/.microemacs_jasspa:${HOME}/programs/microemacs_jasspa
fi

function me ()
{
    argList=""
    while [ $# -ne 0 ]; do
        argList="${argList} $(cygpath -w "$1")"
        shift
    done
    me_exec ${argList} &
}

# function me_old ()
# {
#     argList=""
#     background="&"
#     while [ $# -ne 0 ]; do
#         case $1 in
#         -n) background=""; argList="${argList} $1";;
#         *)  argList="${argList} $1";;
#         esac
#         shift
#     done
# 
#     eval me_exec ${argList} ${background}
# }

# --------------------------------------------------

function tree()
{
    tmpFile=/tmp/tree$$
    find . -type d -print > ${tmpFile}
    topDir=$(pwd)
    trap 'rm -f ${tmpFile}; cd ${topDir}' 2 15
    while read dir; do
        dir="cd ${dir// /\\ }"
        eval "${dir}"
        echo -e "\E[0m\E[36m ${PWD}:\E[0m"
        $@
        cd "${topDir}"
    done < ${tmpFile}
    rm ${tmpFile}
}

# function tree ()
# {
#     top_dir=$(pwd)
#     for dir in $(find . ! -name CVS -type d -print) ; do
#         cd $dir
#         echo $(pwd):
#         "$@"
#         cd $top_dir
#     done
# }

# --------------------------------------------------

# if using ucb mail
# function mail ()
# {
#     curr_dir=$(pwd)
#     cd ~/admin/mail
#     command mail $*
#     cd $curr_dir
# }

# --------------------------------------------------

# If using elm for mail.
# If invoked without args then just check for mail.
# When sending mail I use sed to change the editor of choice
# in elmrc depending on which platform I'm on. This assumes
# VISUAL is previously setup. sed relies on the string "editor = "
# being positioned in column 0 of the elmrc file.
# function elmmail ()
# {
# 	if [ "$#" -eq 0 ]
# 	then
# 		elm -z
# 	else
# 		curr_dir=$(pwd)
# 		sed -e "s?^editor = .*?editor = $VISUAL?" ~/.elm/elmrc > /tmp/howie_elmrc
# 		mv /tmp/howie_elmrc ~/.elm/elmrc
# 		cd ~/admin/mail
# 		elm $@
# 		cd $curr_dir
# 		rm -f ~/Cancelled.mail
# 		rm -f ~/Canceled.mail
# 	fi
# }

# --------------------------------------------------

# If using pine for mail.
# Upon invocation I use sed to change the editor of choice
# in ~/.pinerc depending on which platform I'm on. This assumes
# VISUAL is previously setup. sed relies on the string "editor="
# being positioned in column 0 of the ~/.pinerc file.
# "-d 0" on the command tells pine not to output any debug files
# ".debug-pine?" in the home directory 

function mail()
{
    sed -e "s?^editor=.*?editor=$VISUAL?" ~/.pinerc > /tmp/howie_pinerc
    mv /tmp/howie_pinerc ~/.pinerc
    pine -d 0 $*
    if [ -f ~/dead.letter ]; then
        rm -f ~/dead.letter
    fi
}

# --------------------------------------------------

function start()	# run command in background, redirect std out/error
{
    if [ -d ~/logs ]; then
        logDir=~/logs
    else
        logDir=/tmp
    fi
    "$@" > ${logDir}/logfile 2>&1 &
}

# --------------------------------------------------

function functions ()
{
    typeset -f $*
}

# --------------------------------------------------
#
# Show each component of a PATH like variable on a separate line
#
# example: envshow MANPATH

envshow ()    
{
    if [ $# -ne 1 ]; then
        echo "Supply the name of an environment variable"
        return 1
    fi
    
    # expand the variable's contents
    varName=$1
    varData=$(eval echo "\${${varName}}")
    
    # upon output, substitute a new line for each ":"
    echo -e ${varData//:/'\n'}
}

# --------------------------------------------------
#
# Interactively removes a component of a PATH like variable.
# Lists and prompts for the component to remove.
#
# example: envrm MANPATH

envrm ()
{
    if [ $# -ne 1 ]; then
        echo "Supply the name of an environment variable"
        return 1
    fi
    
    # readability
    varName=$1
    
    # get each component of varName
    entries=$(envshow ${varName})
    
    PS3="Component to remove from \${${varName}}: "
    select d in ${entries}; do
        if [ $d ]; then
            # expand the variable's contents
            varData=$(eval echo "\${${varName}}")
            
            # remove the unwanted component of var
            varData=${varData//$d/}
            
            # clean up left over colons
            varData=${varData//::/:}
            
            # assign it back
            eval ${varName}=${varData}
            break
        else
            echo "Invalid selection."
            echo
        fi
    done
}

# --------------------------------------------------
#
# cd to the path created by substituting $1 for $2 in ${PWD}
# example: cdsub 

cdsub()
{
    cd ${PWD/$1/$2}
}

# --------------------------------------------------

# Include cd history features after cd alias is defined.
if [ -f ~/bin/cd_history ]; then
    . ~/bin/cd_history
fi

# --------------------------------------------------

# end file
